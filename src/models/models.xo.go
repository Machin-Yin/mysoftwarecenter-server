// Package models contains the types for schema 'emind_software_center'.
package models

// GENERATED BY XO. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/csv"
	"errors"
	"fmt"
	"regexp"
	"strings"
)

// ScBanner represents a row from 'emind_software_center.sc_banners'.
type ScBanner struct {
	ID       uint `json:"ID,omitempty" form:"ID"`             // ID
	Priority int8 `json:"priority,omitempty" form:"priority"` // priority

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the ScBanner exists in the database.
func (sb *ScBanner) Exists() bool {
	return sb._exists
}

// Deleted provides information if the ScBanner has been deleted from the database.
func (sb *ScBanner) Deleted() bool {
	return sb._deleted
}

// Insert inserts the ScBanner to the database.
func (sb *ScBanner) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if sb._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO emind_software_center.sc_banners (` +
		`ID, priority` +
		`) VALUES (` +
		`?, ?` +
		`)`

	// run query
	XOLog(sqlstr, sb.ID, sb.Priority)
	_, err = db.Exec(sqlstr, sb.ID, sb.Priority)
	if err != nil {
		return err
	}

	// set existence
	sb._exists = true

	return nil
}

// Update updates the ScBanner in the database.
func (sb *ScBanner) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sb._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if sb._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE emind_software_center.sc_banners SET ` +
		`priority = ?` +
		` WHERE ID = ?`

	// run query
	XOLog(sqlstr, sb.Priority, sb.ID)
	_, err = db.Exec(sqlstr, sb.Priority, sb.ID)
	return err
}

// Save saves the ScBanner to the database.
func (sb *ScBanner) Save(db XODB) error {
	if sb.Exists() {
		return sb.Update(db)
	}

	return sb.Insert(db)
}

// Delete deletes the ScBanner from the database.
func (sb *ScBanner) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sb._exists {
		return nil
	}

	// if deleted, bail
	if sb._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM emind_software_center.sc_banners WHERE ID = ?`

	// run query
	XOLog(sqlstr, sb.ID)
	_, err = db.Exec(sqlstr, sb.ID)
	if err != nil {
		return err
	}

	// set deleted
	sb._deleted = true

	return nil
}

// ScCategory represents a row from 'emind_software_center.sc_category'.
type ScCategory struct {
	ID           uint   `json:"ID,omitempty" form:"ID"`                       // ID
	CategoryName string `json:"category_name,omitempty" form:"category_name"` // category_name

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the ScCategory exists in the database.
func (sc *ScCategory) Exists() bool {
	return sc._exists
}

// Deleted provides information if the ScCategory has been deleted from the database.
func (sc *ScCategory) Deleted() bool {
	return sc._deleted
}

// Insert inserts the ScCategory to the database.
func (sc *ScCategory) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if sc._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO emind_software_center.sc_category (` +
		`category_name` +
		`) VALUES (` +
		`?` +
		`)`

	// run query
	XOLog(sqlstr, sc.CategoryName)
	res, err := db.Exec(sqlstr, sc.CategoryName)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	sc.ID = uint(id)
	sc._exists = true

	return nil
}

// Update updates the ScCategory in the database.
func (sc *ScCategory) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sc._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if sc._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE emind_software_center.sc_category SET ` +
		`category_name = ?` +
		` WHERE ID = ?`

	// run query
	XOLog(sqlstr, sc.CategoryName, sc.ID)
	_, err = db.Exec(sqlstr, sc.CategoryName, sc.ID)
	return err
}

// Save saves the ScCategory to the database.
func (sc *ScCategory) Save(db XODB) error {
	if sc.Exists() {
		return sc.Update(db)
	}

	return sc.Insert(db)
}

// Delete deletes the ScCategory from the database.
func (sc *ScCategory) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sc._exists {
		return nil
	}

	// if deleted, bail
	if sc._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM emind_software_center.sc_category WHERE ID = ?`

	// run query
	XOLog(sqlstr, sc.ID)
	_, err = db.Exec(sqlstr, sc.ID)
	if err != nil {
		return err
	}

	// set deleted
	sc._deleted = true

	return nil
}

// ScComment represents a row from 'emind_software_center.sc_comment'.
type ScComment struct {
	ID           uint   `json:"ID,omitempty" form:"ID"`                       // ID
	ProductID    uint   `json:"product_ID,omitempty" form:"product_ID"`       // product_ID
	ReleaseID    uint   `json:"release_ID,omitempty" form:"release_ID"`       // release_ID
	UserID       uint   `json:"user_ID,omitempty" form:"user_ID"`             // user_ID
	CommentText  string `json:"comment_text,omitempty" form:"comment_text"`   // comment_text
	CommentGrade int8   `json:"comment_grade,omitempty" form:"comment_grade"` // comment_grade
	CommentDate  uint   `json:"comment_date,omitempty" form:"comment_date"`   // comment_date

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the ScComment exists in the database.
func (sc *ScComment) Exists() bool {
	return sc._exists
}

// Deleted provides information if the ScComment has been deleted from the database.
func (sc *ScComment) Deleted() bool {
	return sc._deleted
}

// Insert inserts the ScComment to the database.
func (sc *ScComment) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if sc._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO emind_software_center.sc_comment (` +
		`product_ID, release_ID, user_ID, comment_text, comment_grade, comment_date` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, sc.ProductID, sc.ReleaseID, sc.UserID, sc.CommentText, sc.CommentGrade, sc.CommentDate)
	res, err := db.Exec(sqlstr, sc.ProductID, sc.ReleaseID, sc.UserID, sc.CommentText, sc.CommentGrade, sc.CommentDate)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	sc.ID = uint(id)
	sc._exists = true

	return nil
}

// Update updates the ScComment in the database.
func (sc *ScComment) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sc._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if sc._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE emind_software_center.sc_comment SET ` +
		`product_ID = ?, release_ID = ?, user_ID = ?, comment_text = ?, comment_grade = ?, comment_date = ?` +
		` WHERE ID = ?`

	// run query
	XOLog(sqlstr, sc.ProductID, sc.ReleaseID, sc.UserID, sc.CommentText, sc.CommentGrade, sc.CommentDate, sc.ID)
	_, err = db.Exec(sqlstr, sc.ProductID, sc.ReleaseID, sc.UserID, sc.CommentText, sc.CommentGrade, sc.CommentDate, sc.ID)
	return err
}

// Save saves the ScComment to the database.
func (sc *ScComment) Save(db XODB) error {
	if sc.Exists() {
		return sc.Update(db)
	}

	return sc.Insert(db)
}

// Delete deletes the ScComment from the database.
func (sc *ScComment) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sc._exists {
		return nil
	}

	// if deleted, bail
	if sc._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM emind_software_center.sc_comment WHERE ID = ?`

	// run query
	XOLog(sqlstr, sc.ID)
	_, err = db.Exec(sqlstr, sc.ID)
	if err != nil {
		return err
	}

	// set deleted
	sc._deleted = true

	return nil
}

// ScProduct represents a row from 'emind_software_center.sc_product'.
type ScProduct struct {
	ID                 uint    `json:"ID,omitempty" form:"ID"`                                   // ID
	CategoryID         uint    `json:"category_ID,omitempty" form:"category_ID"`                 // category_ID
	ReleaseID          uint    `json:"release_ID,omitempty" form:"release_ID"`                   // release_ID
	ProductName        string  `json:"product_name,omitempty" form:"product_name"`               // product_name
	VendorName         string  `json:"vendor_name,omitempty" form:"vendor_name"`                 // vendor_name
	IconURL            string  `json:"icon_url,omitempty" form:"icon_url"`                       // icon_url
	URL                string  `json:"url,omitempty" form:"url"`                                 // url
	ProductDescription string  `json:"product_description,omitempty" form:"product_description"` // product_description
	ProductGrade       uint    `json:"product_grade,omitempty" form:"product_grade"`             // product_grade
	GradeCount         float32 `json:"grade_count,omitempty" form:"grade_count"`                 // grade_count
	ExecutableFile     string  `json:"executable_file,omitempty" form:"executable_file"`         // executable_file
	PackageName        string  `json:"package_name,omitempty" form:"package_name"`               // package_name

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the ScProduct exists in the database.
func (sp *ScProduct) Exists() bool {
	return sp._exists
}

// Deleted provides information if the ScProduct has been deleted from the database.
func (sp *ScProduct) Deleted() bool {
	return sp._deleted
}

// Insert inserts the ScProduct to the database.
func (sp *ScProduct) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if sp._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO emind_software_center.sc_product (` +
		`category_ID, release_ID, product_name, vendor_name, icon_url, url, product_description, product_grade, grade_count, executable_file, package_name` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, sp.CategoryID, sp.ReleaseID, sp.ProductName, sp.VendorName, sp.IconURL, sp.URL, sp.ProductDescription, sp.ProductGrade, sp.GradeCount, sp.ExecutableFile, sp.PackageName)
	res, err := db.Exec(sqlstr, sp.CategoryID, sp.ReleaseID, sp.ProductName, sp.VendorName, sp.IconURL, sp.URL, sp.ProductDescription, sp.ProductGrade, sp.GradeCount, sp.ExecutableFile, sp.PackageName)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	sp.ID = uint(id)
	sp._exists = true

	return nil
}

// Update updates the ScProduct in the database.
func (sp *ScProduct) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sp._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if sp._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE emind_software_center.sc_product SET ` +
		`category_ID = ?, release_ID = ?, product_name = ?, vendor_name = ?, icon_url = ?, url = ?, product_description = ?, product_grade = ?, grade_count = ?, executable_file = ?, package_name = ?` +
		` WHERE ID = ?`

	// run query
	XOLog(sqlstr, sp.CategoryID, sp.ReleaseID, sp.ProductName, sp.VendorName, sp.IconURL, sp.URL, sp.ProductDescription, sp.ProductGrade, sp.GradeCount, sp.ExecutableFile, sp.PackageName, sp.ID)
	_, err = db.Exec(sqlstr, sp.CategoryID, sp.ReleaseID, sp.ProductName, sp.VendorName, sp.IconURL, sp.URL, sp.ProductDescription, sp.ProductGrade, sp.GradeCount, sp.ExecutableFile, sp.PackageName, sp.ID)
	return err
}

// Save saves the ScProduct to the database.
func (sp *ScProduct) Save(db XODB) error {
	if sp.Exists() {
		return sp.Update(db)
	}

	return sp.Insert(db)
}

// Delete deletes the ScProduct from the database.
func (sp *ScProduct) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sp._exists {
		return nil
	}

	// if deleted, bail
	if sp._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM emind_software_center.sc_product WHERE ID = ?`

	// run query
	XOLog(sqlstr, sp.ID)
	_, err = db.Exec(sqlstr, sp.ID)
	if err != nil {
		return err
	}

	// set deleted
	sp._deleted = true

	return nil
}

// ScRecommend represents a row from 'emind_software_center.sc_recommend'.
type ScRecommend struct {
	ID       uint `json:"ID,omitempty" form:"ID"`             // ID
	Priority int8 `json:"priority,omitempty" form:"priority"` // priority

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the ScRecommend exists in the database.
func (sr *ScRecommend) Exists() bool {
	return sr._exists
}

// Deleted provides information if the ScRecommend has been deleted from the database.
func (sr *ScRecommend) Deleted() bool {
	return sr._deleted
}

// Insert inserts the ScRecommend to the database.
func (sr *ScRecommend) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if sr._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO emind_software_center.sc_recommend (` +
		`ID, priority` +
		`) VALUES (` +
		`?, ?` +
		`)`

	// run query
	XOLog(sqlstr, sr.ID, sr.Priority)
	_, err = db.Exec(sqlstr, sr.ID, sr.Priority)
	if err != nil {
		return err
	}

	// set existence
	sr._exists = true

	return nil
}

// Update updates the ScRecommend in the database.
func (sr *ScRecommend) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sr._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if sr._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE emind_software_center.sc_recommend SET ` +
		`priority = ?` +
		` WHERE ID = ?`

	// run query
	XOLog(sqlstr, sr.Priority, sr.ID)
	_, err = db.Exec(sqlstr, sr.Priority, sr.ID)
	return err
}

// Save saves the ScRecommend to the database.
func (sr *ScRecommend) Save(db XODB) error {
	if sr.Exists() {
		return sr.Update(db)
	}

	return sr.Insert(db)
}

// Delete deletes the ScRecommend from the database.
func (sr *ScRecommend) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sr._exists {
		return nil
	}

	// if deleted, bail
	if sr._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM emind_software_center.sc_recommend WHERE ID = ?`

	// run query
	XOLog(sqlstr, sr.ID)
	_, err = db.Exec(sqlstr, sr.ID)
	if err != nil {
		return err
	}

	// set deleted
	sr._deleted = true

	return nil
}

// ScRelease represents a row from 'emind_software_center.sc_release'.
type ScRelease struct {
	ID             uint    `json:"ID,omitempty" form:"ID"`                           // ID
	ProductID      uint    `json:"product_ID,omitempty" form:"product_ID"`           // product_ID
	ProductName    string  `json:"product_name,omitempty" form:"product_name"`       // product_name
	Version        string  `json:"version,omitempty" form:"version"`                 // version
	IconURL        string  `json:"icon_url,omitempty" form:"icon_url"`               // icon_url
	DownloadURL    string  `json:"download_url,omitempty" form:"download_url"`       // download_url
	Changelog      string  `json:"changelog,omitempty" form:"changelog"`             // changelog
	PackageSize    uint    `json:"package_size,omitempty" form:"package_size"`       // package_size
	PackageType    int8    `json:"package_type,omitempty" form:"package_type"`       // package_type
	ReleaseGrade   uint    `json:"release_grade,omitempty" form:"release_grade"`     // release_grade
	GradeCount     float32 `json:"grade_count,omitempty" form:"grade_count"`         // grade_count
	ReleaseDate    uint    `json:"release_date,omitempty" form:"release_date"`       // release_date
	ExecutableFile string  `json:"executable_file,omitempty" form:"executable_file"` // executable_file
	PackageName    string  `json:"package_name,omitempty" form:"package_name"`       // package_name

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the ScRelease exists in the database.
func (sr *ScRelease) Exists() bool {
	return sr._exists
}

// Deleted provides information if the ScRelease has been deleted from the database.
func (sr *ScRelease) Deleted() bool {
	return sr._deleted
}

// Insert inserts the ScRelease to the database.
func (sr *ScRelease) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if sr._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO emind_software_center.sc_release (` +
		`product_ID, product_name, version, icon_url, download_url, changelog, package_size, package_type, release_grade, grade_count, release_date, executable_file, package_name` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, sr.ProductID, sr.ProductName, sr.Version, sr.IconURL, sr.DownloadURL, sr.Changelog, sr.PackageSize, sr.PackageType, sr.ReleaseGrade, sr.GradeCount, sr.ReleaseDate, sr.ExecutableFile, sr.PackageName)
	res, err := db.Exec(sqlstr, sr.ProductID, sr.ProductName, sr.Version, sr.IconURL, sr.DownloadURL, sr.Changelog, sr.PackageSize, sr.PackageType, sr.ReleaseGrade, sr.GradeCount, sr.ReleaseDate, sr.ExecutableFile, sr.PackageName)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	sr.ID = uint(id)
	sr._exists = true

	return nil
}

// Update updates the ScRelease in the database.
func (sr *ScRelease) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sr._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if sr._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE emind_software_center.sc_release SET ` +
		`product_ID = ?, product_name = ?, version = ?, icon_url = ?, download_url = ?, changelog = ?, package_size = ?, package_type = ?, release_grade = ?, grade_count = ?, release_date = ?, executable_file = ?, package_name = ?` +
		` WHERE ID = ?`

	// run query
	XOLog(sqlstr, sr.ProductID, sr.ProductName, sr.Version, sr.IconURL, sr.DownloadURL, sr.Changelog, sr.PackageSize, sr.PackageType, sr.ReleaseGrade, sr.GradeCount, sr.ReleaseDate, sr.ExecutableFile, sr.PackageName, sr.ID)
	_, err = db.Exec(sqlstr, sr.ProductID, sr.ProductName, sr.Version, sr.IconURL, sr.DownloadURL, sr.Changelog, sr.PackageSize, sr.PackageType, sr.ReleaseGrade, sr.GradeCount, sr.ReleaseDate, sr.ExecutableFile, sr.PackageName, sr.ID)
	return err
}

// Save saves the ScRelease to the database.
func (sr *ScRelease) Save(db XODB) error {
	if sr.Exists() {
		return sr.Update(db)
	}

	return sr.Insert(db)
}

// Delete deletes the ScRelease from the database.
func (sr *ScRelease) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !sr._exists {
		return nil
	}

	// if deleted, bail
	if sr._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM emind_software_center.sc_release WHERE ID = ?`

	// run query
	XOLog(sqlstr, sr.ID)
	_, err = db.Exec(sqlstr, sr.ID)
	if err != nil {
		return err
	}

	// set deleted
	sr._deleted = true

	return nil
}

// ScScreenImage represents a row from 'emind_software_center.sc_screen_image'.
type ScScreenImage struct {
	ID        uint   `json:"ID,omitempty" form:"ID"`                 // ID
	ProductID uint   `json:"product_ID,omitempty" form:"product_ID"` // product_ID
	ReleaseID uint   `json:"release_ID,omitempty" form:"release_ID"` // release_ID
	ImageURL  string `json:"image_url,omitempty" form:"image_url"`   // image_url

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the ScScreenImage exists in the database.
func (ssi *ScScreenImage) Exists() bool {
	return ssi._exists
}

// Deleted provides information if the ScScreenImage has been deleted from the database.
func (ssi *ScScreenImage) Deleted() bool {
	return ssi._deleted
}

// Insert inserts the ScScreenImage to the database.
func (ssi *ScScreenImage) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if ssi._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO emind_software_center.sc_screen_image (` +
		`product_ID, release_ID, image_url` +
		`) VALUES (` +
		`?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, ssi.ProductID, ssi.ReleaseID, ssi.ImageURL)
	res, err := db.Exec(sqlstr, ssi.ProductID, ssi.ReleaseID, ssi.ImageURL)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	ssi.ID = uint(id)
	ssi._exists = true

	return nil
}

// Update updates the ScScreenImage in the database.
func (ssi *ScScreenImage) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !ssi._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if ssi._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE emind_software_center.sc_screen_image SET ` +
		`product_ID = ?, release_ID = ?, image_url = ?` +
		` WHERE ID = ?`

	// run query
	XOLog(sqlstr, ssi.ProductID, ssi.ReleaseID, ssi.ImageURL, ssi.ID)
	_, err = db.Exec(sqlstr, ssi.ProductID, ssi.ReleaseID, ssi.ImageURL, ssi.ID)
	return err
}

// Save saves the ScScreenImage to the database.
func (ssi *ScScreenImage) Save(db XODB) error {
	if ssi.Exists() {
		return ssi.Update(db)
	}

	return ssi.Insert(db)
}

// Delete deletes the ScScreenImage from the database.
func (ssi *ScScreenImage) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !ssi._exists {
		return nil
	}

	// if deleted, bail
	if ssi._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM emind_software_center.sc_screen_image WHERE ID = ?`

	// run query
	XOLog(sqlstr, ssi.ID)
	_, err = db.Exec(sqlstr, ssi.ID)
	if err != nil {
		return err
	}

	// set deleted
	ssi._deleted = true

	return nil
}

// ScUser represents a row from 'emind_software_center.sc_user'.
type ScUser struct {
	ID        uint   `json:"ID,omitempty" form:"ID"`                 // ID
	UserName  string `json:"user_name,omitempty" form:"user_name"`   // user_name
	AvatarURL string `json:"avatar_url,omitempty" form:"avatar_url"` // avatar_url
	Mail      string `json:"mail,omitempty" form:"mail"`             // mail

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the ScUser exists in the database.
func (su *ScUser) Exists() bool {
	return su._exists
}

// Deleted provides information if the ScUser has been deleted from the database.
func (su *ScUser) Deleted() bool {
	return su._deleted
}

// Insert inserts the ScUser to the database.
func (su *ScUser) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if su._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO emind_software_center.sc_user (` +
		`user_name, avatar_url, mail` +
		`) VALUES (` +
		`?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, su.UserName, su.AvatarURL, su.Mail)
	res, err := db.Exec(sqlstr, su.UserName, su.AvatarURL, su.Mail)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	su.ID = uint(id)
	su._exists = true

	return nil
}

// Update updates the ScUser in the database.
func (su *ScUser) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !su._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if su._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE emind_software_center.sc_user SET ` +
		`user_name = ?, avatar_url = ?, mail = ?` +
		` WHERE ID = ?`

	// run query
	XOLog(sqlstr, su.UserName, su.AvatarURL, su.Mail, su.ID)
	_, err = db.Exec(sqlstr, su.UserName, su.AvatarURL, su.Mail, su.ID)
	return err
}

// Save saves the ScUser to the database.
func (su *ScUser) Save(db XODB) error {
	if su.Exists() {
		return su.Update(db)
	}

	return su.Insert(db)
}

// Delete deletes the ScUser from the database.
func (su *ScUser) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !su._exists {
		return nil
	}

	// if deleted, bail
	if su._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM emind_software_center.sc_user WHERE ID = ?`

	// run query
	XOLog(sqlstr, su.ID)
	_, err = db.Exec(sqlstr, su.ID)
	if err != nil {
		return err
	}

	// set deleted
	su._deleted = true

	return nil
}

// ScProduct returns the ScProduct associated with the ScBanner's ID (ID).
//
// Generated from foreign key 'sc_banners_ibfk_1'.
func (sb *ScBanner) ScProduct(db XODB) (*ScProduct, error) {
	return ScProductByID(db, sb.ID)
}

// ScProduct returns the ScProduct associated with the ScComment's ProductID (product_ID).
//
// Generated from foreign key 'sc_comment_ibfk_1'.
func (sc *ScComment) ScProduct(db XODB) (*ScProduct, error) {
	return ScProductByID(db, sc.ProductID)
}

// ScRelease returns the ScRelease associated with the ScComment's ReleaseID (release_ID).
//
// Generated from foreign key 'sc_comment_ibfk_2'.
func (sc *ScComment) ScRelease(db XODB) (*ScRelease, error) {
	return ScReleaseByID(db, sc.ReleaseID)
}

// ScUser returns the ScUser associated with the ScComment's UserID (user_ID).
//
// Generated from foreign key 'sc_comment_ibfk_3'.
func (sc *ScComment) ScUser(db XODB) (*ScUser, error) {
	return ScUserByID(db, sc.UserID)
}

// ScCategory returns the ScCategory associated with the ScProduct's CategoryID (category_ID).
//
// Generated from foreign key 'sc_product_ibfk_1'.
func (sp *ScProduct) ScCategory(db XODB) (*ScCategory, error) {
	return ScCategoryByID(db, sp.CategoryID)
}

// ScProduct returns the ScProduct associated with the ScRecommend's ID (ID).
//
// Generated from foreign key 'sc_recommend_ibfk_1'.
func (sr *ScRecommend) ScProduct(db XODB) (*ScProduct, error) {
	return ScProductByID(db, sr.ID)
}

// ScProduct returns the ScProduct associated with the ScRelease's ProductID (product_ID).
//
// Generated from foreign key 'sc_release_ibfk_1'.
func (sr *ScRelease) ScProduct(db XODB) (*ScProduct, error) {
	return ScProductByID(db, sr.ProductID)
}

// ScProduct returns the ScProduct associated with the ScScreenImage's ProductID (product_ID).
//
// Generated from foreign key 'sc_screen_image_ibfk_1'.
func (ssi *ScScreenImage) ScProduct(db XODB) (*ScProduct, error) {
	return ScProductByID(db, ssi.ProductID)
}

// ScRelease returns the ScRelease associated with the ScScreenImage's ReleaseID (release_ID).
//
// Generated from foreign key 'sc_screen_image_ibfk_2'.
func (ssi *ScScreenImage) ScRelease(db XODB) (*ScRelease, error) {
	return ScReleaseByID(db, ssi.ReleaseID)
}

// ScBannerByID retrieves a row from 'emind_software_center.sc_banners' as a ScBanner.
//
// Generated from index 'sc_banners_ID_pkey'.
func ScBannerByID(db XODB, id uint) (*ScBanner, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, priority ` +
		`FROM emind_software_center.sc_banners ` +
		`WHERE ID = ?`

	// run query
	XOLog(sqlstr, id)
	sb := ScBanner{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&sb.ID, &sb.Priority)
	if err != nil {
		return nil, err
	}

	return &sb, nil
}

// ScCategoryByID retrieves a row from 'emind_software_center.sc_category' as a ScCategory.
//
// Generated from index 'sc_category_ID_pkey'.
func ScCategoryByID(db XODB, id uint) (*ScCategory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, category_name ` +
		`FROM emind_software_center.sc_category ` +
		`WHERE ID = ?`

	// run query
	XOLog(sqlstr, id)
	sc := ScCategory{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&sc.ID, &sc.CategoryName)
	if err != nil {
		return nil, err
	}

	return &sc, nil
}

// ScCommentByID retrieves a row from 'emind_software_center.sc_comment' as a ScComment.
//
// Generated from index 'sc_comment_ID_pkey'.
func ScCommentByID(db XODB, id uint) (*ScComment, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, product_ID, release_ID, user_ID, comment_text, comment_grade, comment_date ` +
		`FROM emind_software_center.sc_comment ` +
		`WHERE ID = ?`

	// run query
	XOLog(sqlstr, id)
	sc := ScComment{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&sc.ID, &sc.ProductID, &sc.ReleaseID, &sc.UserID, &sc.CommentText, &sc.CommentGrade, &sc.CommentDate)
	if err != nil {
		return nil, err
	}

	return &sc, nil
}

// ScCommentsByProductID retrieves a row from 'emind_software_center.sc_comment' as a ScComment.
//
// Generated from index 'sc_comment_ibfk_1'.
func ScCommentsByProductID(db XODB, productID uint) ([]*ScComment, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, product_ID, release_ID, user_ID, comment_text, comment_grade, comment_date ` +
		`FROM emind_software_center.sc_comment ` +
		`WHERE product_ID = ?`

	// run query
	XOLog(sqlstr, productID)
	q, err := db.Query(sqlstr, productID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScComment{}
	for q.Next() {
		sc := ScComment{
			_exists: true,
		}

		// scan
		err = q.Scan(&sc.ID, &sc.ProductID, &sc.ReleaseID, &sc.UserID, &sc.CommentText, &sc.CommentGrade, &sc.CommentDate)
		if err != nil {
			return nil, err
		}

		res = append(res, &sc)
	}

	return res, nil
}

// ScCommentsByReleaseID retrieves a row from 'emind_software_center.sc_comment' as a ScComment.
//
// Generated from index 'sc_comment_ibfk_2'.
func ScCommentsByReleaseID(db XODB, releaseID uint) ([]*ScComment, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, product_ID, release_ID, user_ID, comment_text, comment_grade, comment_date ` +
		`FROM emind_software_center.sc_comment ` +
		`WHERE release_ID = ?`

	// run query
	XOLog(sqlstr, releaseID)
	q, err := db.Query(sqlstr, releaseID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScComment{}
	for q.Next() {
		sc := ScComment{
			_exists: true,
		}

		// scan
		err = q.Scan(&sc.ID, &sc.ProductID, &sc.ReleaseID, &sc.UserID, &sc.CommentText, &sc.CommentGrade, &sc.CommentDate)
		if err != nil {
			return nil, err
		}

		res = append(res, &sc)
	}

	return res, nil
}

// ScCommentsByUserID retrieves a row from 'emind_software_center.sc_comment' as a ScComment.
//
// Generated from index 'sc_comment_ibfk_3'.
func ScCommentsByUserID(db XODB, userID uint) ([]*ScComment, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, product_ID, release_ID, user_ID, comment_text, comment_grade, comment_date ` +
		`FROM emind_software_center.sc_comment ` +
		`WHERE user_ID = ?`

	// run query
	XOLog(sqlstr, userID)
	q, err := db.Query(sqlstr, userID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScComment{}
	for q.Next() {
		sc := ScComment{
			_exists: true,
		}

		// scan
		err = q.Scan(&sc.ID, &sc.ProductID, &sc.ReleaseID, &sc.UserID, &sc.CommentText, &sc.CommentGrade, &sc.CommentDate)
		if err != nil {
			return nil, err
		}

		res = append(res, &sc)
	}

	return res, nil
}

// ScProductsByCategoryID retrieves a row from 'emind_software_center.sc_product' as a ScProduct.
//
// Generated from index 'category_ID'.
func ScProductsByCategoryID(db XODB, categoryID uint) ([]*ScProduct, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, category_ID, release_ID, product_name, vendor_name, icon_url, url, product_description, product_grade, grade_count, executable_file, package_name ` +
		`FROM emind_software_center.sc_product ` +
		`WHERE category_ID = ?`

	// run query
	XOLog(sqlstr, categoryID)
	q, err := db.Query(sqlstr, categoryID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScProduct{}
	for q.Next() {
		sp := ScProduct{
			_exists: true,
		}

		// scan
		err = q.Scan(&sp.ID, &sp.CategoryID, &sp.ReleaseID, &sp.ProductName, &sp.VendorName, &sp.IconURL, &sp.URL, &sp.ProductDescription, &sp.ProductGrade, &sp.GradeCount, &sp.ExecutableFile, &sp.PackageName)
		if err != nil {
			return nil, err
		}

		res = append(res, &sp)
	}

	return res, nil
}

// ScProductsByProductName retrieves a row from 'emind_software_center.sc_product' as a ScProduct.
//
// Generated from index 'product_name'.
func ScProductsByProductName(db XODB, productName string) ([]*ScProduct, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, category_ID, release_ID, product_name, vendor_name, icon_url, url, product_description, product_grade, grade_count, executable_file, package_name ` +
		`FROM emind_software_center.sc_product ` +
		`WHERE product_name = ?`

	// run query
	XOLog(sqlstr, productName)
	q, err := db.Query(sqlstr, productName)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScProduct{}
	for q.Next() {
		sp := ScProduct{
			_exists: true,
		}

		// scan
		err = q.Scan(&sp.ID, &sp.CategoryID, &sp.ReleaseID, &sp.ProductName, &sp.VendorName, &sp.IconURL, &sp.URL, &sp.ProductDescription, &sp.ProductGrade, &sp.GradeCount, &sp.ExecutableFile, &sp.PackageName)
		if err != nil {
			return nil, err
		}

		res = append(res, &sp)
	}

	return res, nil
}

// ScProductByID retrieves a row from 'emind_software_center.sc_product' as a ScProduct.
//
// Generated from index 'sc_product_ID_pkey'.
func ScProductByID(db XODB, id uint) (*ScProduct, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, category_ID, release_ID, product_name, vendor_name, icon_url, url, product_description, product_grade, grade_count, executable_file, package_name ` +
		`FROM emind_software_center.sc_product ` +
		`WHERE ID = ?`

	// run query
	XOLog(sqlstr, id)
	sp := ScProduct{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&sp.ID, &sp.CategoryID, &sp.ReleaseID, &sp.ProductName, &sp.VendorName, &sp.IconURL, &sp.URL, &sp.ProductDescription, &sp.ProductGrade, &sp.GradeCount, &sp.ExecutableFile, &sp.PackageName)
	if err != nil {
		return nil, err
	}

	return &sp, nil
}

// ScProductsByVendorName retrieves a row from 'emind_software_center.sc_product' as a ScProduct.
//
// Generated from index 'vendor_name'.
func ScProductsByVendorName(db XODB, vendorName string) ([]*ScProduct, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, category_ID, release_ID, product_name, vendor_name, icon_url, url, product_description, product_grade, grade_count, executable_file, package_name ` +
		`FROM emind_software_center.sc_product ` +
		`WHERE vendor_name = ?`

	// run query
	XOLog(sqlstr, vendorName)
	q, err := db.Query(sqlstr, vendorName)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScProduct{}
	for q.Next() {
		sp := ScProduct{
			_exists: true,
		}

		// scan
		err = q.Scan(&sp.ID, &sp.CategoryID, &sp.ReleaseID, &sp.ProductName, &sp.VendorName, &sp.IconURL, &sp.URL, &sp.ProductDescription, &sp.ProductGrade, &sp.GradeCount, &sp.ExecutableFile, &sp.PackageName)
		if err != nil {
			return nil, err
		}

		res = append(res, &sp)
	}

	return res, nil
}

// ScRecommendByID retrieves a row from 'emind_software_center.sc_recommend' as a ScRecommend.
//
// Generated from index 'sc_recommend_ID_pkey'.
func ScRecommendByID(db XODB, id uint) (*ScRecommend, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, priority ` +
		`FROM emind_software_center.sc_recommend ` +
		`WHERE ID = ?`

	// run query
	XOLog(sqlstr, id)
	sr := ScRecommend{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&sr.ID, &sr.Priority)
	if err != nil {
		return nil, err
	}

	return &sr, nil
}

// ScReleaseByID retrieves a row from 'emind_software_center.sc_release' as a ScRelease.
//
// Generated from index 'sc_release_ID_pkey'.
func ScReleaseByID(db XODB, id uint) (*ScRelease, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, product_ID, product_name, version, icon_url, download_url, changelog, package_size, package_type, release_grade, grade_count, release_date, executable_file, package_name ` +
		`FROM emind_software_center.sc_release ` +
		`WHERE ID = ?`

	// run query
	XOLog(sqlstr, id)
	sr := ScRelease{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&sr.ID, &sr.ProductID, &sr.ProductName, &sr.Version, &sr.IconURL, &sr.DownloadURL, &sr.Changelog, &sr.PackageSize, &sr.PackageType, &sr.ReleaseGrade, &sr.GradeCount, &sr.ReleaseDate, &sr.ExecutableFile, &sr.PackageName)
	if err != nil {
		return nil, err
	}

	return &sr, nil
}

// ScReleasesByProductID retrieves a row from 'emind_software_center.sc_release' as a ScRelease.
//
// Generated from index 'sc_release_ibfk_1'.
func ScReleasesByProductID(db XODB, productID uint) ([]*ScRelease, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, product_ID, product_name, version, icon_url, download_url, changelog, package_size, package_type, release_grade, grade_count, release_date, executable_file, package_name ` +
		`FROM emind_software_center.sc_release ` +
		`WHERE product_ID = ?`

	// run query
	XOLog(sqlstr, productID)
	q, err := db.Query(sqlstr, productID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScRelease{}
	for q.Next() {
		sr := ScRelease{
			_exists: true,
		}

		// scan
		err = q.Scan(&sr.ID, &sr.ProductID, &sr.ProductName, &sr.Version, &sr.IconURL, &sr.DownloadURL, &sr.Changelog, &sr.PackageSize, &sr.PackageType, &sr.ReleaseGrade, &sr.GradeCount, &sr.ReleaseDate, &sr.ExecutableFile, &sr.PackageName)
		if err != nil {
			return nil, err
		}

		res = append(res, &sr)
	}

	return res, nil
}

// ScScreenImageByID retrieves a row from 'emind_software_center.sc_screen_image' as a ScScreenImage.
//
// Generated from index 'sc_screen_image_ID_pkey'.
func ScScreenImageByID(db XODB, id uint) (*ScScreenImage, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, product_ID, release_ID, image_url ` +
		`FROM emind_software_center.sc_screen_image ` +
		`WHERE ID = ?`

	// run query
	XOLog(sqlstr, id)
	ssi := ScScreenImage{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&ssi.ID, &ssi.ProductID, &ssi.ReleaseID, &ssi.ImageURL)
	if err != nil {
		return nil, err
	}

	return &ssi, nil
}

// ScScreenImagesByProductID retrieves a row from 'emind_software_center.sc_screen_image' as a ScScreenImage.
//
// Generated from index 'sc_screen_image_ibfk_1'.
func ScScreenImagesByProductID(db XODB, productID uint) ([]*ScScreenImage, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, product_ID, release_ID, image_url ` +
		`FROM emind_software_center.sc_screen_image ` +
		`WHERE product_ID = ?`

	// run query
	XOLog(sqlstr, productID)
	q, err := db.Query(sqlstr, productID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScScreenImage{}
	for q.Next() {
		ssi := ScScreenImage{
			_exists: true,
		}

		// scan
		err = q.Scan(&ssi.ID, &ssi.ProductID, &ssi.ReleaseID, &ssi.ImageURL)
		if err != nil {
			return nil, err
		}

		res = append(res, &ssi)
	}

	return res, nil
}

// ScScreenImagesByReleaseID retrieves a row from 'emind_software_center.sc_screen_image' as a ScScreenImage.
//
// Generated from index 'sc_screen_image_ibfk_2'.
func ScScreenImagesByReleaseID(db XODB, releaseID uint) ([]*ScScreenImage, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, product_ID, release_ID, image_url ` +
		`FROM emind_software_center.sc_screen_image ` +
		`WHERE release_ID = ?`

	// run query
	XOLog(sqlstr, releaseID)
	q, err := db.Query(sqlstr, releaseID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScScreenImage{}
	for q.Next() {
		ssi := ScScreenImage{
			_exists: true,
		}

		// scan
		err = q.Scan(&ssi.ID, &ssi.ProductID, &ssi.ReleaseID, &ssi.ImageURL)
		if err != nil {
			return nil, err
		}

		res = append(res, &ssi)
	}

	return res, nil
}

// ScUserByID retrieves a row from 'emind_software_center.sc_user' as a ScUser.
//
// Generated from index 'sc_user_ID_pkey'.
func ScUserByID(db XODB, id uint) (*ScUser, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`ID, user_name, avatar_url, mail ` +
		`FROM emind_software_center.sc_user ` +
		`WHERE ID = ?`

	// run query
	XOLog(sqlstr, id)
	su := ScUser{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&su.ID, &su.UserName, &su.AvatarURL, &su.Mail)
	if err != nil {
		return nil, err
	}

	return &su, nil
}

// XODB is the common interface for database operations that can be used with
// types from schema 'emind_software_center'.
//
// This should work with database/sql.DB and database/sql.Tx.
type XODB interface {
	Exec(string, ...interface{}) (sql.Result, error)
	Query(string, ...interface{}) (*sql.Rows, error)
	QueryRow(string, ...interface{}) *sql.Row
}

// XOLog provides the log func used by generated queries.
var XOLog = func(string, ...interface{}) {}

// ScannerValuer is the common interface for types that implement both the
// database/sql.Scanner and sql/driver.Valuer interfaces.
type ScannerValuer interface {
	sql.Scanner
	driver.Valuer
}

// StringSlice is a slice of strings.
type StringSlice []string

// quoteEscapeRegex is the regex to match escaped characters in a string.
var quoteEscapeRegex = regexp.MustCompile(`([^\\]([\\]{2})*)\\"`)

// Scan satisfies the sql.Scanner interface for StringSlice.
func (ss *StringSlice) Scan(src interface{}) error {
	buf, ok := src.([]byte)
	if !ok {
		return errors.New("invalid StringSlice")
	}

	// change quote escapes for csv parser
	str := quoteEscapeRegex.ReplaceAllString(string(buf), `$1""`)
	str = strings.Replace(str, `\\`, `\`, -1)

	// remove braces
	str = str[1 : len(str)-1]

	// bail if only one
	if len(str) == 0 {
		*ss = StringSlice([]string{})
		return nil
	}

	// parse with csv reader
	cr := csv.NewReader(strings.NewReader(str))
	slice, err := cr.Read()
	if err != nil {
		fmt.Printf("exiting!: %v\n", err)
		return err
	}

	*ss = StringSlice(slice)

	return nil
}

// Value satisfies the driver.Valuer interface for StringSlice.
func (ss StringSlice) Value() (driver.Value, error) {
	v := make([]string, len(ss))
	for i, s := range ss {
		v[i] = `"` + strings.Replace(strings.Replace(s, `\`, `\\\`, -1), `"`, `\"`, -1) + `"`
	}
	return "{" + strings.Join(v, ",") + "}", nil
}

// Slice is a slice of ScannerValuers.
type Slice []ScannerValuer

// GetScProducts runs a custom query, returning results as ScProduct.
func GetScProducts(db XODB) ([]*ScProduct, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`* ` +
		`FROM sc_product`

	// run query
	XOLog(sqlstr)
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScProduct{}
	for q.Next() {
		sp := ScProduct{}

		// scan
		err = q.Scan(&sp.ID, &sp.CategoryID, &sp.ReleaseID, &sp.ProductName, &sp.VendorName, &sp.IconURL, &sp.URL, &sp.ProductDescription, &sp.ProductGrade, &sp.GradeCount, &sp.ExecutableFile, &sp.PackageName)
		if err != nil {
			return nil, err
		}

		res = append(res, &sp)
	}

	return res, nil
}

// GetScCategories runs a custom query, returning results as ScCategory.
func GetScCategories(db XODB) ([]*ScCategory, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`* ` +
		`FROM sc_category`

	// run query
	XOLog(sqlstr)
	q, err := db.Query(sqlstr)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*ScCategory{}
	for q.Next() {
		sc := ScCategory{}

		// scan
		err = q.Scan(&sc.ID, &sc.CategoryName)
		if err != nil {
			return nil, err
		}

		res = append(res, &sc)
	}

	return res, nil
}
